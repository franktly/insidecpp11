#include<iostream>

// nullptr
// 0 && NULL && (void*)0 && nullptr
//
// NULL is a macro defination like below(stddef.h):
/*
 * 
 * #undef NULL
 * #if defined(__cplusplus)
 * #define NULL 0  // literal const 0
 * #else
 * #define NULl ((void*)0)  // none-type pointer const
 * #endif
 */
// nullptr:  empty pointer type(nullptr_t) const
// nullptr_t: the type of nullptr
// nullptr_t rules:
// 1. all nullptr_t type var is equality and the same behavior
// 2. nullptr_t type can convert to any pointer type implicitly
// 3. nullptr_t type can NOT convert to none-pointer type even using reinterpret_cast
// 4. nullptr_t type arithmetic expression is NOT allowed
// 5. nullptr_t type relationship expression is allowed only with another nullptr_t type or pointer type //GCC UNALLOWED
//

void func(char* c)
{
    std::cout << "invoke func(char*)" << std::endl;
}

void func(int i)
{
    std::cout << "invoke func(int)" << std::endl;
}

// template deduce nullptr to a normal type NOT a pointer type
//
template<typename T> void g(T* t) {}
template<typename T> void h(T t) {}

void nullptrTest()
{
    func(0);   // invoke int
    // func(NULL);  // error: calling is  ambiguous (NULL --> __null inner transition in GCC)
    func((char*)0); // invoke char*
    func(nullptr); // invoke char*

    // nullptr_t rules test
    char *p = nullptr;  // 2 allowed

    // int n1 = nullptr; // 3 error: unallowed
    // int n2 = reinterpret_cast<int>(nullptr); // 3 error: unallowed

    std::nullptr_t nptr;
    if(nptr == nullptr)
    {
        std::cout << "nullptr_t nptr  == nullptr" << std::endl;
    }
    // else if( nptr < nullptr)
    // {
    // std::cout << "nullptr_t nptr  < nullptr" << std::endl;
    // }
    // else if(nptr > nullptr)
    // {
    // std::cout << "nullptr_t nptr  > nullptr" << std::endl;
    // }
    else
    {
        std::cout << "nullptr_t nptr  != nullptr" << std::endl;
    }

    // if( 0 == nullptr)  // 3. error: unallowed 
    // if(nullptr) // 3. error: unallowed
    // nullptr += 1; // 4. error: unallowed;

    std::cout << "sizeof(nullptr) = " << sizeof(nullptr) << std::endl;;
    std::cout << "typeif(nullptr) = " << typeid(nullptr).name() << std::endl;;
    // throw(nullptr); ok

    // nullptr template deduce
    // g(nullptr);  error: nullptr is NOT a point type at deduce
    g((float*)nullptr);

    h(0);
    h(nullptr);
    h((float*)nullptr);
}

int main(int argc, char** argv)
{
    nullptrTest();

    return 0;
}
